require('dotenv').config();
const mysql = require('mysql2/promise');
const bcrypt = require('bcrypt');
const { generateUsername } = require('unique-username-generator')
const { UserDTO } = require('./user_dto');
const crypto = require("crypto");


const DB_HOST = process.env.DB_HOST;
const MYSQL_USER = process.env.MYSQL_USER;
const MYSQL_PASSWORD = process.env.MYSQL_PASSWORD;
const MYSQL_DATABASE = process.env.MYSQL_DATABASE;


const pool = mysql.createPool({
  host: DB_HOST,
  user: MYSQL_USER,
  password: MYSQL_PASSWORD,
  database: MYSQL_DATABASE,
  port: 3306,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});


/**
 * @brief Checks whether a username already exists in the users table.
 * 
 * @param {*} username The username to check.
 * @returns true if the username is already taken, false otherwise
 */
async function usernameTaken(username){
	//check users table for existing user with this username
	const [rows] =  await pool.execute(
		'SELECT id FROM users WHERE username = ?',
		[username]
	);
	return (rows.length > 0);
}

/**
 * @brief Wraps bcrypt.hash() with the configured salt rounds and hashes a plaintext password
 * 
 * @param {*} password the plaintext password to encrypt
 * @returns the hash
 */
function hashWord(password) {
  let saltRounds = 10;
	return bcrypt.hash(password, Number(saltRounds));
}

/**
 * @brief Creates a new user account in the database with the given information
 * 
 * Ensures username uniqueness, auto-generates a username if not provided,
 * hashes the password, and inserts a new row into the users table.
 * 
 * @param username the new user's username
 * @param email the new user's email address
 * @param password the new user's plaintext password
 * @returns  An object containing { id, username, email } for the newly created user
 * 
 * @throws 409 if the username is already taken.
 */
async function createUser({username, email, password}) {
  console.log("Made it here 1")
	//verify uniqueness first
	const trimmed = typeof username === 'string' ? username.trim() : ''; //handles any type of non-valid username
	username = trimmed;

  console.log("Made it here 2")

	if(!username){
		username = generateUsername("",2);
		while (await usernameTaken(username)){
			username = generateUsername("", 2);
		}
	}

  console.log("Made it here 3")
	if( await usernameTaken(username)) {  //stops account creation if username is taken
		const err = new Error('username has been taken');
		err.status = 409;
		throw err;		
	}

  console.log("Made it here 4")
  console.log("username = ", username, " email = ", email,  " password = ", password);
	//hash the password and insert into users table
	// const hash = await bcrypt.hash(password, Number(saltRounds));
	const hash = await hashWord(password); // hashword returns a promise, need to await it
  console.log("after hashWord")
  console.log("hash = ", hash, " username = ", username, " email = ", email);

	const [result] = await pool.execute(
	    'INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)',
    	[username, email, hash]
  	);

  console.log("Made it here 5")

	return {id: result.insertId, username, email};

}

/**
 * @brief Verifies the user's login credentials
 * 
 * @param email the user's email address
 * @param password the user's plaintext password to use 
 * @returns true if authentication succeeds, false otherwise
 */
async function verifyUser({ email, password }) {
  if (!email || !password) return false;

  const [rows] = await pool.execute(
    'SELECT password_hash FROM users WHERE email = ?',
    [email]
  );

  if (!rows.length) return false;

  const hash = rows[0].password_hash;
  return bcrypt.compare(password, hash);
}

/**
 * @brief Issues a trivial query to ensure the DB connection is healthy
 * 
 * @returns true if the query succeeds
 * @throws Any connection or query error from the db query
 */
async function dbPing() {
	await pool.query('SELECT 1');
	return true;
}

/**
 * @brief Gets the username associated with the account given by the email address
 * 
 * @param {*} email the email to fetch
 * @returns The username string, or undefined if not found
 */
async function fetchUsername(email){ //this might create some security issues
	const [rows] = await pool.execute(
		'SELECT * FROM users WHERE email = ?',
		[email]
	);
	return rows[0].username;
}

/**
 * @brief Gets a user's profile information by ID
 * 
 * Queries the users table and merges results with a predefined UserDTO.
 * 
 * @param {*} uid the user's unique, autogenerated ID
 * @returns A user DTO object, or null if no record exists
 */
async function fetchUserbyUID(uid){
	const [rows] = await pool.execute(
		'SELECT id, username, email, bio, verified FROM `users` WHERE id = ?',
		[uid]
	);
	const row = rows[0];
	if (!row) return null;
	return{ ...UserDTO, ...row}
}

/**
 * @brief Gets a user's profile information by email address
 * 
 * Queries the users table and merges results with a predefined UserDTO.
 * 
 * @param {*} email the user's email address
 * @returns A user DTO object, or null if no record exists
 */
async function fetchUserbyEmail(email){
	const [rows] = await pool.execute(
	'SELECT id, username, email, bio, verified FROM `users` WHERE email = ?',
	[email]
	);
	const row = rows[0];
	if (!row) return null;
	return{ ...UserDTO, ...row}
}

/**
 * @brief Generates and stores a one-time email verification token
 *
 * Creates a cryptographically secure token, sets an expiration, and inserts
 * the record into the email_tokens table
 *
 * @param {*} uid The ID of the user requesting verification
 * @returns The generated token string
 */
async function createEmailToken(uid){
	const token = crypto.randomBytes(32).toString('hex');
	const expiresAt = new Date(Date.now() + 1000 * 60 * 60); // 1 hour from creation

	const [rows] = await pool.execute(
	'INSERT INTO email_tokens (user_id, token, expires_at) VALUES (?, ?, ?)',
	[uid, token, expiresAt]
	);
	
	return token;
	// return rows[0].token;
}

/**
 * @brief Validates and consumes an email verification token
 *
 * Checks the email_tokens table for the provided token, ensures it is usable
 * (not expired and not previously used), marks it as used, and returns
 * the associated user ID.
 *
 * @param {*} token The token string received from the user
 * @returns The user ID if the token is valid, null otherwise
 */
async function consumeEmailToken(token) {
  const [rows] = await pool.execute(
    'SELECT * FROM email_tokens WHERE token = ?',
    [token]
  );
  const record = rows[0];
  if (!record) return null;

  const now = new Date();
  if (record.used || new Date(record.expires_at) < now) {
    return null;
  }

  // mark used
  await pool.execute(
    'UPDATE email_tokens SET used = 1 WHERE id = ?',
    [record.id]
  );
  return record.user_id;
}

/**
 * @brief Marks a user's email address as verified
 *
 * Sets the `verified` flag in the users table.
 *
 * @param {*} uid The user ID to update
 */
async function verifyAccountEmail(uid){
	await pool.execute(
	'UPDATE users SET verified = 1 where id = ?',
	[uid]
	);
}

/**
 * @brief Permanently deletes a user record
 *
 * Removes the user from the database by ID.
 *
 * @param {*} id The user ID to delete
 * @returns void
 */
async function deleteUser(id) {
  await pool.execute(
    'DELETE FROM email_tokens WHERE user_id = ?', 
    [id]);
  await pool.execute(
    'DELETE FROM users WHERE id = ?', 
    [id]
  );
} 

//this is a testing suite, we should not be hard coding our functions with test variables

async function test(){

}

module.exports = { createUser, usernameTaken, verifyUser, dbPing, hashWord, fetchUsername, fetchUserbyUID, fetchUserbyEmail, createEmailToken, consumeEmailToken, verifyAccountEmail, deleteUser}; 